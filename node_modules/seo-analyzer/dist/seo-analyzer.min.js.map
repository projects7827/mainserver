{"version":3,"file":"seo-analyzer.min.js","sources":["../src/rules/index.js","../src/rules/TitleLengthRule.js","../src/rules/ImgTagWithAltAttributeRule.js","../src/rules/ATagWithRelAttributeRule.js","../src/rules/CanonicalLinkRule.js","../src/rules/MetaBaseRule.js","../src/rules/MetaSocialRule.js","../src/modules/logger.js","../src/modules/scraper.js","../src/modules/input.js","../src/modules/analyzer.js","../src/modules/output.js","../src/modules/next-server.js","../src/server.js","../src/index.js"],"sourcesContent":["import titleLengthRule from './TitleLengthRule';\nimport imgTagWithAltAttributeRule from './ImgTagWithAltAttributeRule';\nimport aTagWithRelAttributeRule from './ATagWithRelAttributeRule';\nimport canonicalLinkRule from './CanonicalLinkRule';\nimport metaBaseRule from './MetaBaseRule';\nimport metaSocialRule from './MetaSocialRule';\n\nconst defaultRules = {\n  titleLengthRule,\n  imgTagWithAltAttributeRule,\n  aTagWithRelAttributeRule,\n  canonicalLinkRule,\n  metaBaseRule,\n  metaSocialRule\n};\n\nexport default defaultRules;\n","function titleLengthRule(dom, options) {\n  return new Promise(resolve => {\n    const document = dom.window.document;\n    const title = document.querySelector('title');\n    if (!title) {\n      resolve('This HTML without <title> tag');\n    }\n    // If title exists in the DOM\n    const titleLength = title.length;\n    if (titleLength < options.min) {\n      resolve(\n        `<title> too short(${titleLength}). The minimum length should be ${options.min} characters.`\n      );\n    }\n    if (titleLength > options.max) {\n      resolve(\n        `<title> too long(${titleLength}). The maximum length should be ${options.max} characters.`\n      );\n    }\n    resolve(null);\n  });\n}\n\nexport default titleLengthRule;\n","function imgTagWithAltAttributeRule(dom) {\n  return new Promise(resolve => {\n    let countAlt = 0;\n    let countSrc = 0;\n    const report = [];\n    const elements = dom.window.document.querySelectorAll('img');\n\n    elements.forEach(element => {\n      if (!element.alt) {\n        countAlt++;\n      }\n      if (!element.src) {\n        countSrc++;\n      }\n    });\n\n    if (countSrc > 0) {\n      report.push(`There are ${countSrc} <img> tag without src attribute`);\n    }\n\n    if (countAlt > 0) {\n      report.push(`There are ${countAlt} <img> tag without alt attribute`);\n    }\n\n    if (countSrc || countAlt) {\n      resolve(report);\n    }\n\n    resolve(null);\n  });\n}\n\nexport default imgTagWithAltAttributeRule;\n","function ATagWithRelAttributeRule(dom) {\n  return new Promise(resolve => {\n    let count = 0;\n    const elements = dom.window.document.querySelectorAll('a');\n    elements.forEach(element => {\n      if (!element.rel) {\n        count++;\n      }\n    });\n    if (count > 0) {\n      resolve(`There are ${count} <a> tag without rel attribute`);\n    }\n    resolve(null);\n  });\n}\n\nexport default ATagWithRelAttributeRule;\n","function canonicalLinkRule(dom) {\n  return new Promise(resolve => {\n    const element = dom.window.document.querySelector(\n      'head > link[rel=\"canonical\"]'\n    );\n    if (!element) {\n      resolve('This HTML without <link rel=\"canonical\" href=\"...\"> link');\n    }\n    if (element && !element.href) {\n      resolve('The canonical link without href attribute');\n    }\n    if (element && element.href.substr(-1) !== '/') {\n      resolve(\n        'The href attribute does not have a slash at the end of the link.'\n      );\n    }\n    resolve(null);\n  });\n}\n\nexport default canonicalLinkRule;\n","function metaBaseRule(dom, options = { list: [] }) {\n  return new Promise(resolve => {\n    const report = [];\n    if (options && options.names && options.names.length) {\n      options.names.forEach(name => {\n        const element = dom.window.document.querySelector(\n          `head > meta[name=\"${name}\"]`\n        );\n        if (!element) {\n          report.push(`This HTML without <meta name=\"${name}\"> tag`);\n        } else if (!element.content) {\n          report.push(\n            `The content attribute for the <meta name=\"${name}\" content=\"\"> tag is empty`\n          );\n        }\n      });\n    }\n    resolve(report);\n  });\n}\n\nexport default metaBaseRule;\n","function metaSocialRule(dom, options = { properties: [] }) {\n  return new Promise(resolve => {\n    const report = [];\n    if (options && options.properties && options.properties.length) {\n      options.properties.forEach(property => {\n        const element = dom.window.document.querySelector(\n          `head > meta[property=\"${property}\"]`\n        );\n        if (!element) {\n          report.push(`This HTML without <meta property=\"${property}\"> tag`);\n        } else if (!element.content) {\n          report.push(\n            `The content attribute for the <meta property=\"${property}\" content=\"\"> tag is empty`\n          );\n        }\n      });\n    }\n    resolve(report);\n  });\n}\n\nexport default metaSocialRule;\n","import CFonts from 'cfonts';\nimport _colors from 'colors';\n\nclass Analyzer {\n  /**\n   * Print formatted result to console\n   * @param {Array} - Array of reports\n   * @returns {Error} - Stop execution and print error\n   */\n  result(result) {\n    this._logResult(result);\n  }\n\n  /**\n   * Print error message to console\n   * @param {String} - Message\n   * @returns {String} - Print formatted message to console\n   */\n  error(error, exit) {\n    this._logError(error);\n    if (exit) process.exit(1);\n  }\n\n  /**\n   * Print success message to console\n   * @param {String} - Message\n   * @returns {String} - Print formatted message to console\n   */\n  success(success) {\n    this._logSuccess(success);\n  }\n\n  /**\n   * Print info message to console\n   * @param {String} - Message\n   * @returns {String} - Print formatted message to console\n   */\n  info(info) {\n    this._logInfo(info);\n  }\n\n  /**\n   * Print beautiful message to console\n   * @param {String} - Result message\n   * @returns {String} - Print CFonts message to console\n   */\n  printTextToConsole(text) {\n    const formattedText = text.replace(' ', '|');\n    CFonts.say(formattedText, {\n      font: 'block', // define the font face\n      align: 'left', // define text alignment\n      colors: ['system'], // define all colors\n      background: 'transparent', // define the background color, you can also use `backgroundColor` here as key\n      letterSpacing: 1, // define letter spacing\n      lineHeight: 1, // define the line height\n      space: true, // define if the output text should have empty lines on top and on the bottom\n      maxLength: '0', // define how many character can be on one line\n      gradient: false, // define your two gradient colors\n      independentGradient: false, // define if you want to recalculate the gradient for each new line\n      transitionGradient: false, // define if this is a transition between colors directly\n      env: 'node' // define the environment CFonts is being executed in\n    });\n  }\n\n  /**\n   * @param {Array} - Array of reports\n   * @returns {Error} - Stop execution and print error\n   * @private\n   * @memberof Analyzer\n   * @description Print result message to console\n   */\n  _logResult(result) {\n    if (!result.some(r => r.report.length))\n      return this._logSuccess('\\nüëç SEO defects were not detected.\\n');\n\n    this._logInfo('\\nüöÄ  Report of errors');\n\n    for (const item of result) {\n      this._logInfo(`\\nFile: ${item.source.trim()}`);\n      this._logError(`${item.report.join('\\n')}`);\n    }\n\n    this._logSuccess(\n      '\\n-------- üöÄ Finished! --------\\nThanks for using Seo Analyzer!\\n'\n    );\n\n    return process.exit(1); // Stop process in terminal\n  }\n\n  /**\n   * @param {String} - Error object\n   * @returns {String} - Stop execution and print error\n   * @private\n   * @memberof Analyzer\n   * @description Print error message to console\n   */\n  _logError(error) {\n    console.error(`${_colors.red(error)}`);\n  }\n\n  /**\n   * @param {String} - Error object\n   * @returns {String} - Stop execution and print error\n   * @private\n   * @memberof Analyzer\n   * @description Print error message to console\n   */\n  _logInfo(info) {\n    console.log(`${_colors.yellow(info)}`);\n  }\n\n  /**\n   * @param {String} - Message\n   * @returns {String} - Print formatted message to console\n   * @private\n   * @memberof Analyzer\n   */\n  _logSuccess(success) {\n    console.log(`${_colors.green(success)}`);\n  }\n}\n\nexport default Analyzer;\n","import axios from 'axios';\nimport sitemaps from 'sitemap-stream-parser';\nimport cliProgress from 'cli-progress';\nimport _colors from 'colors';\nimport Logger from './logger';\n\nclass Scanner {\n  constructor() {\n    this.consoleProgressBar = new cliProgress.Bar({\n      format:\n        'Processing... |' +\n        _colors.green('{bar}') +\n        '| {percentage}% || {value}/{total} Pages',\n      barCompleteChar: '\\u2588',\n      barIncompleteChar: '\\u2591',\n      hideCursor: true\n    });\n    this.logger = new Logger();\n    this.inputUrl = '';\n    this.ignoreUrls = '';\n  }\n\n  /**\n   * @param {Number} port - Port for the server to listen on\n   * @returns {Array} - Array of html doms\n   * @description - Scrapes the site and returns the html doms\n   */\n  async run(port, urls, sitemap) {\n    this.inputUrl = `http://localhost:${port}`;\n    this.ignoreUrls = urls;\n    const links = await this._getLinksFromSitemap(sitemap);\n    const htmlDoms = await this._getHtmlDomFromLinks(links);\n    return htmlDoms;\n  }\n\n  /**\n   * Get the links from the sitemap\n   * @returns {Array} - Array of links\n   * @description - Scrapes the sitemap and returns the links\n   */\n  _getLinksFromSitemap(sitemap) {\n    this.logger.info(`üöÄ  Get sitemap from ${this.inputUrl}\\n`);\n    return new Promise(resolve => {\n      const formattedUrl = `${this.inputUrl}/${sitemap}`;\n      const links = [];\n      sitemaps.parseSitemaps(\n        formattedUrl,\n        link => {\n          // Ignore the links that are in the ignore list\n          const path = link.replace(/^.*\\/\\/[^/]+/, '');\n          if (this.ignoreUrls.indexOf(path) === -1) {\n            links.push(this._formatLink(link));\n          }\n        },\n        err => {\n          if (err) {\n            this.logger.error('‚ùå  Sitemap not found\\n', 1);\n          } else {\n            if (!links.length) {\n              this.logger.error('‚ùå  Links not found\\n', 1);\n            } else {\n              this.logger.success('‚úÖ  Done\\n');\n              resolve(links);\n            }\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Formats the link to be used in axios\n   * @param {String} link\n   * @returns {String} - Formatted link > http://localhost:{port}/link\n   */\n  _formatLink(link) {\n    const result = link.replace(/^.*\\/\\/[^/]+/, this.inputUrl);\n    return result;\n  }\n\n  /**\n   * Sleep for the given time in milliseconds\n   * @param {Number} ms\n   * @returns {Promise}\n   */\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get the html doms from the links\n   * @param {Array} links - Array of links\n   * @returns {Array} - Array of html doms\n   * @description - Scrapes the links and returns the html doms\n   */\n  async _getHtmlDomFromLinks(links) {\n    const htmlDoms = [];\n    const promises = [];\n    this.logger.info('üöÄ  Parsing HTML\\n');\n\n    // Start the progress bar\n    this.consoleProgressBar.start(links.length, 0);\n\n    for (const link of links) {\n      promises.push(\n        axios\n          .get(link)\n          .then(res => {\n            if (res && res.status === 200) {\n              htmlDoms.push({ source: link, text: res.data });\n            }\n          })\n          .catch(error => {\n            const err =\n              (error && error.response && error.response.status) || 500;\n            console.log(`Error: ${error} - ${link}`);\n            console.log(\n              `\\n${_colors.yellow('==>')} ${_colors.white(link)} ${_colors.red(\n                err\n              )}`\n            );\n          })\n          .finally(() => {\n            this.consoleProgressBar.increment();\n          })\n      );\n      await this.sleep(500);\n    }\n\n    return Promise.all(promises).then(() => {\n      // // Stop the progress bar\n      this.consoleProgressBar.stop();\n      return htmlDoms;\n    });\n  }\n}\n\nexport default Scanner;\n","import fs from 'fs';\nimport path from 'path';\nimport { JSDOM, VirtualConsole } from 'jsdom';\nimport cliProgress from 'cli-progress';\nimport _colors from 'colors';\nimport Logger from './logger';\nimport Scraper from './scraper';\n\nclass Input {\n  constructor() {\n    this.logger = new Logger();\n    this.scraper = new Scraper();\n    this.consoleProgressBar = new cliProgress.Bar({\n      format:\n        'Processing... |' +\n        _colors.green('{bar}') +\n        '| {percentage}% || {value}/{total} Folders',\n      barCompleteChar: '\\u2588',\n      barIncompleteChar: '\\u2591',\n      hideCursor: true\n    });\n    this.badType =\n      'The inputFiles function takes an array only [\"index.html\", \"...\", \"...\"]';\n    this.emptyList =\n      'You need to pass an array to the inputFiles function [\"index.html\", \"...\", \"...\"]';\n    this.ignoreFolders = [];\n    this.ignoreFiles = [];\n  }\n\n  /**\n   * Get the html from files\n   * @param {Array} files [<string>, <string>, ...]\n   * @param ignoreFiles\n   * @returns {Promise.Array} [{ window: {}, document: {}, ... }, { window: {}, document: {}, ... }, ...]\n   * @memberof Input\n   */\n  async files(files = [], ignoreFiles = []) {\n    if (!Array.isArray(files) || !files.length)\n      this.logger.error('‚ùå  The \"inputFiles\" method expects an array of files.\\n', true);\n\n    if (!Array.isArray(ignoreFiles))\n      this.logger.error('‚ùå  The \"ignoreFiles\" method expects an array of ignore files.\\n', true);\n\n    this.logger.info('\\nüöÄ  Parsing files\\n');\n    if (files.length === 0) {\n      this.logger.error(this.emptyList);\n    }\n    if (!Array.isArray(files)) {\n      this.logger.error(this.badType);\n    }\n    this.ignoreFiles = ignoreFiles;\n    const listTexts = await this._getHtml(files);\n    const listDOM = await this._getDom(listTexts);\n    return listDOM;\n  }\n\n  /**\n   * Get the html from files in folders\n   * @param {string} folders [<string>, <string>, ...]\n   * @param ignoreFolders\n   * @param ignoreFiles\n   * @returns {Promise.Array} [{ window: {}, document: {}, ... }, { window: {}, document: {}, ... }, ...]\n   * @memberof Input\n   */\n  async folders(folders = [], ignoreFolders = [], ignoreFiles = []) {\n    if (!Array.isArray(folders) || !folders.length)\n      this.logger.error('‚ùå  The \"inputFolders\" method expects an array of folders.\\n', true);\n\n    if (!Array.isArray(ignoreFolders))\n      this.logger.error('‚ùå  The \"ignoreFolders\" method expects an array of ignore folders.\\n', true);\n\n    this.logger.info('üöÄ  Parsing folders\\n');\n\n    // Start the progress bar\n    this.consoleProgressBar.start(folders.length, 0);\n    this.ignoreFolders = ignoreFolders;\n    this.ignoreFiles = ignoreFiles;\n\n    const files = await this._getFilesFromFolders(folders);\n    const listDOM = await this.files(files, ignoreFiles);\n    return listDOM;\n  }\n\n  /**\n   * Get the DOM from urls\n   * @returns {Promise.Array} [{ window: {}, document: {}, ... }, { window: {}, document: {}, ... }, ...]\n   * @param port\n   * @param ignoreUrls\n   */\n  async spa(port, ignoreUrls = [], sitemap) {\n    const listTexts = await this.scraper.run(port, ignoreUrls, sitemap);\n    const htmlDoms = await this._getDom(listTexts);\n    return htmlDoms;\n  }\n\n  /**\n   * Get all files from folders\n   * @param {Array} folders [<string>, <string>, ...]\n   * @returns {Promise.Array} [<string>, <string>, ...]\n   * @private\n   * @example ['html', 'dist', 'src']\n   */\n  async _getFilesFromFolders(folders = []) {\n    const files = [];\n    for (const folder of folders) {\n      const result = await this._getFilesFromFolder(folder);\n\n      // Update the progress bar\n      this.consoleProgressBar.increment();\n\n      files.push(...result);\n    }\n\n    // Stop the progress bar\n    this.consoleProgressBar.stop();\n\n    if (!files.length) this.logger.error('\\n‚ùå  No files found.\\n', true);\n\n    return files;\n  }\n\n  /**\n   * Get files from folder\n   * @param {string} folder\n   * @returns {Promise.Array} [<string>, <string>, ...]\n   * @private\n   * @memberof Input\n   */\n  _getFilesFromFolder(folder = []) {\n    try {\n      const entryPaths = fs\n        .readdirSync(folder)\n        .map(entry => path.join(folder, entry));\n      const filePaths = entryPaths.filter(\n        entryPath =>\n          fs.statSync(entryPath).isFile() && path.extname(entryPath) === '.html'\n      );\n      const dirPaths = entryPaths.filter(\n        entryPath =>\n          !filePaths.includes(entryPath) && fs.statSync(entryPath).isDirectory()\n      );\n      const dirFiles = dirPaths\n        .filter(p => !this.ignoreFolders.includes(p))\n        .reduce(\n          (prev, curr) => prev.concat(this._getFilesFromFolder(curr)),\n          []\n        );\n      return [...filePaths, ...dirFiles];\n    } catch (error) {\n      this.logger.error(`\\n\\n‚ùå Folder \"${folder}\" not found\\n`);\n      return [];\n    }\n  }\n\n  /**\n   * Get the html from file\n   * @param {*} files [<string>, <string>, ...]\n   * @returns {Promise.Array} ['<html><body>...</body></html>', '<html><body>...</body></html>', ...]\n   * @private\n   * @memberof Input\n   */\n  _getHtml(files) {\n    const listTexts = [];\n    const proccess = new cliProgress.Bar({\n      format:\n        'Processing... |' +\n        _colors.green('{bar}') +\n        '| {percentage}% || {value}/{total} Sources',\n      barCompleteChar: '\\u2588',\n      barIncompleteChar: '\\u2591',\n      hideCursor: true\n    });\n\n    // Start the progress bar\n    proccess.start(files.length, 0);\n\n    files.forEach(file => {\n      if (this.ignoreFiles.includes(file)) return;\n      try {\n        const text = fs.readFileSync(file, 'utf8');\n        listTexts.push({ source: file, text });\n        proccess.increment();\n      } catch (error) {\n        proccess.increment();\n        this.logger.error(`\\n\\nFile \"${file}\" not found\\n`);\n      }\n    });\n    proccess.stop();\n    if (!listTexts.length) this.logger.error('\\n‚ùå  No files found.\\n', true);\n    return listTexts;\n  }\n\n  /**\n   * Transform html to DOM\n   * @param {Array} list [<string>, <string>, ...]\n   * @returns {Promise.Array} [{ window: {}, document: {}, ... }, { window: {}, document: {}, ... }, ...]\n   * @private\n   */\n  _getDom(list) {\n    const doms = [];\n    const proccess = new cliProgress.Bar({\n      format:\n        'Handling html |' +\n        _colors.green('{bar}') +\n        '| {percentage}% || {value}/{total} Sources',\n      barCompleteChar: '\\u2588',\n      barIncompleteChar: '\\u2591',\n      hideCursor: true\n    });\n    this.logger.info('\\nüöÄ  Get DOM from HTML\\n');\n    proccess.start(list.length, 0);\n    // NOTE: https://github.com/jsdom/jsdom/issues/2177#issuecomment-379212964\n    const virtualConsole = new VirtualConsole();\n    list.forEach(item => {\n      let dom = new JSDOM(item.text, { virtualConsole });\n      doms.push({ source: item.source, dom });\n      proccess.increment();\n    });\n\n    proccess.stop();\n    return doms;\n  }\n}\n\nexport default Input;\n","import cliProgress from 'cli-progress';\nimport _colors from 'colors';\n\nclass Analyzer {\n  constructor() {\n    this.consoleProgressBar = new cliProgress.Bar({\n      format:\n        'Ranning rules |' +\n        _colors.green('{bar}') +\n        '| {percentage}% || {value}/{total} Rules',\n      barCompleteChar: '\\u2588',\n      barIncompleteChar: '\\u2591',\n      hideCursor: true\n    });\n    this.badType =\n      'The inputFiles function takes an array only [\"index.html\", \"...\", \"...\"]';\n    this.emptyList =\n      'You need to pass an array to the inputFiles function [\"index.html\", \"...\", \"...\"]';\n  }\n\n  /**\n   * Run analyzer for a list of doms\n   * @param {JSDOM<array>} doms - The html dom list to run the rule on\n   * @param {Array} rules - The rules to run\n   * @returns {Array} - Array of error result [{ file, report }, { file, report }, { file, report }]\n   */\n  async run(inputData, rules) {\n    if (inputData.length === 0) {\n      this.logger.error(this.emptyList);\n    }\n    if (!Array.isArray(inputData)) {\n      this.logger.error(this.badType);\n    }\n    const report = await this._startAnalyzer(inputData, rules);\n    return report;\n  }\n\n  /**\n   * @param {Array} dataList - html doms\n   * @param {Array} rules - List rulers\n   * @returns {Array} - Array of reports [{file, report}, {file, report}, {file, report}]\n   */\n  async _startAnalyzer(dataList, rules) {\n    const result = [];\n    for (const item of dataList) {\n      console.log(\n        `\\n${_colors.blue('==>')} Analysis ${_colors.white(item.source)}`\n      );\n\n      const report = await this._analyzeDOM(item.dom, rules);\n\n      if (report && report.length) {\n        result.push({\n          source: item.source,\n          report\n        });\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Run analyzer for a single dom\n   * @param {*} dom - The html dom element to run the rule on\n   * @param {*} rules - The rules to run\n   * @returns {Array} - Array of error result ['error', 'error', 'error']\n   */\n  async _analyzeDOM(dom, rules) {\n    const result = [];\n    // Start the progress bar\n    this.consoleProgressBar.start(rules.length, 0);\n\n    for (const item of rules) {\n      let report = null;\n      try {\n        report = await item.rule(dom, item.options);\n      } catch (error) {\n        report = error;\n      }\n      if (Array.isArray(report)) {\n        result.push(...report);\n      } else {\n        if (report) {\n          result.push(report);\n        }\n      }\n\n      // Update the progress bar\n      this.consoleProgressBar.increment();\n    }\n\n    // Stop the progress bar\n    this.consoleProgressBar.stop();\n\n    return result;\n  }\n}\n\nexport default Analyzer;\n","import Analyzer from './analyzer';\n\nclass Output {\n  constructor() {\n    this.analyzer = new Analyzer();\n  }\n\n  /**\n   * @param {Array} data - List of files and folders\n   * @param {Array} rules - List of rules\n   * @returns {Promise} - Returns js object [{file, report}, ...]\n   */\n  async object(inputData, rules) {\n    const report = await this.analyzer.run(inputData, rules);\n    return report;\n  }\n\n  /**\n   * @param {Array} data - List of files and folders\n   * @param {Array} rules - List of rules\n   * @returns {JSON} - Returns json [{\"file\", \"report\"}, ...]\n   */\n  async json(inputData, rules) {\n    const report = await this.analyzer.run(inputData, rules);\n    return JSON.stringify(report, null, 2);\n  }\n}\n\nexport default Output;\n","import express from 'express';\nimport next from 'next';\nimport Logger from './logger';\nimport Input from './input';\n\nclass NextServer {\n  constructor() {\n    this.logger = new Logger();\n    this._input = new Input();\n    this.port = parseInt(process.env.PORT, 10) || 3000;\n    this.app = next({ dev: false });\n    this.handle = this.app.getRequestHandler();\n    this.status = {};\n  }\n\n  /**\n   * Run Next js server\n   * @returns {Promise<unknown>}\n   */\n  run() {\n    return new Promise((resolve, reject) => {\n      this.app.prepare()\n        .then(() => {\n          const server = express();\n\n          server.all('*', (req, res) => {\n            return this.handle(req, res);\n          });\n\n          server.listen(this.port, err => {\n            if (err) throw err;\n            this.logger.info(`üöÄ  Ready on http://localhost:${this.port}\\n`);\n            resolve({ status: 'Active' });\n          });\n        })\n        .catch(ex => {\n          this.logger.error('‚ùå  Error Starting Server\\n');\n          console.error(ex.stack);\n          process.exit(1);\n          reject(new Error('Error Starting Server'));\n        });\n    });\n  }\n\n  /**\n   * Run server for next js.\n   * Get the DOM from urls\n   * @param {number} port\n   * @param ignoreUrls\n   * @returns {Promise<Promise.Array>}\n   */\n  async inputSSR(port, ignoreUrls = [], sitemap) {\n    this.port = port;\n    this.status = await this.run();\n    const inputResult = this._input.spa(this.port, ignoreUrls, sitemap);\n    return inputResult;\n  }\n}\n\nexport default NextServer;\n","import express from 'express';\nimport path from 'path';\nimport Logger from './modules/logger';\n\nconst app = express();\n\nconst logger = new Logger();\n\n/**\n * Start the server on the given port and use static files from the given path.\n * @param {String} folder - The path to the static files.\n * @param {Number} port - The port to start the server on.\n */\nexport function startServer(folder, port) {\n  app.use(express.static(folder));\n\n  // sendFile will go here\n  app.get('/', (req, res) => {\n    res.sendFile(path.join(__dirname, '/index.html'));\n  });\n\n  app.listen(port);\n\n  logger.info(`üöÄ  Server started on port ${port}\\n`);\n\n  logger.success('‚úÖ  Done\\n');\n}\n","import defaultRules from './rules/index';\n\nimport Input from './modules/input';\nimport Output from './modules/output';\nimport Logger from './modules/logger';\nimport NextServer from './modules/next-server';\n\nimport { startServer } from './server';\n\nclass SeoAnalyzer {\n  constructor() {\n    this._logger = new Logger();\n    this._input = new Input();\n    this._output = new Output();\n    this._nextServer = new NextServer();\n    this._inputData = [];\n    this._defaultRules = defaultRules;\n    this._rules = [];\n    this._ignoreFolders = [];\n    this._ignoreFiles = [];\n    this._ignoreUrls = [];\n    return this;\n  }\n\n  // --------- Ignore methods --------- //\n  ignoreFiles(files) {\n    this._ignoreFiles = files;\n    return this;\n  }\n\n  ignoreFolders(folders) {\n    this._ignoreFolders = folders;\n    return this;\n  }\n\n  ignoreUrls(urls) {\n    this._ignoreUrls = urls;\n    return this;\n  }\n\n  // ------- Input methods ------- //\n  inputFiles(files) {\n    if (this._inputData.length !== 0) return this;\n    this._logger.printTextToConsole('SEO Analyzer');\n    this._inputData = this._input.files(files, this._ignoreFiles);\n    return this;\n  }\n\n  inputFolders(folders) {\n    if (this._inputData.length !== 0) return this;\n    this._logger.printTextToConsole('SEO Analyzer');\n    this._inputData = this._input.folders(\n      folders,\n      this._ignoreFolders,\n      this._ignoreFiles\n    );\n    return this;\n  }\n\n  inputSpaFolder(folder, sitemap='sitemap.xml', port = 9999) {\n    if (!this._inputData) return this;\n    this._logger.printTextToConsole('SEO Analyzer');\n    // Run server for spa\n    startServer(folder, port);\n    this._inputData = this._input.spa(port, this._ignoreUrls, sitemap);\n    return this;\n  }\n\n  inputNextJs(sitemap='sitemap.xml', port = 3000) {\n    if (!this._inputData) return this;\n    this._logger.printTextToConsole('SEO Analyzer');\n    this._inputData = this._nextServer.inputSSR(port, this._ignoreUrls, sitemap);\n    return this;\n  }\n\n  // --------- Add Rule --------- //\n  addRule(func, options = {}) {\n    if (typeof func === 'string') {\n      if (func in defaultRules) {\n        this._rules.push({ rule: defaultRules[func], options });\n      } else {\n        this._logger.error(`\\n\\n‚ùå  Rule \"${func}\" not found\\n`, 1);\n      }\n    } else if (typeof func === 'function') {\n      this._rules.push({ rule: func, options });\n    } else {\n      this._logger.error('\\n\\n‚ùå  Rule must be a function or a string\\n', 1);\n    }\n    return this;\n  }\n\n  // ------- Output methods ------- //\n  outputConsole() {\n    (async () => {\n      const json = await this._output.object(await this._inputData, this._rules);\n      this._logger.result(json);\n    })();\n    return this;\n  }\n\n  outputJson(callback) {\n    (async () => {\n      const json = await this._output.json(await this._inputData, this._rules);\n      callback(json);\n    })();\n    return this;\n  }\n\n  outputObject(callback) {\n    (async () => {\n      const obj = await this._output.object(await this._inputData, this._rules);\n      callback(obj);\n    })();\n    return this;\n  }\n}\n\nexport default SeoAnalyzer;\n"],"names":["defaultRules","titleLengthRule","dom","options","Promise","resolve","title","window","document","querySelector","titleLength","length","min","max","imgTagWithAltAttributeRule","countAlt","countSrc","report","querySelectorAll","forEach","element","alt","src","push","count","rel","canonicalLinkRule","href","substr","metaBaseRule","list","names","name","content","metaSocialRule","properties","property","Analyzer","[object Object]","result","this","_logResult","error","exit","_logError","process","success","_logSuccess","info","_logInfo","text","formattedText","replace","CFonts","say","font","align","colors","background","letterSpacing","lineHeight","space","maxLength","gradient","independentGradient","transitionGradient","env","some","r","item","source","trim","join","console","_colors","red","log","yellow","green","Scanner","consoleProgressBar","cliProgress","Bar","format","barCompleteChar","barIncompleteChar","hideCursor","logger","Logger","inputUrl","ignoreUrls","port","urls","sitemap","links","_getLinksFromSitemap","_getHtmlDomFromLinks","formattedUrl","sitemaps","parseSitemaps","link","path","indexOf","_formatLink","err","ms","setTimeout","htmlDoms","promises","start","axios","get","then","res","status","data","catch","response","white","finally","increment","sleep","all","stop","Input","scraper","Scraper","badType","emptyList","ignoreFolders","ignoreFiles","files","Array","isArray","listTexts","_getHtml","_getDom","folders","_getFilesFromFolders","run","folder","_getFilesFromFolder","entryPaths","fs","readdirSync","map","entry","filePaths","filter","entryPath","statSync","isFile","extname","dirFiles","includes","isDirectory","p","reduce","prev","curr","concat","proccess","file","readFileSync","doms","virtualConsole","VirtualConsole","JSDOM","inputData","rules","_startAnalyzer","dataList","blue","_analyzeDOM","rule","Output","analyzer","JSON","stringify","NextServer","_input","parseInt","PORT","app","next","dev","handle","getRequestHandler","reject","prepare","server","express","req","listen","ex","stack","Error","spa","_logger","_output","_nextServer","_inputData","_defaultRules","_rules","_ignoreFolders","_ignoreFiles","_ignoreUrls","printTextToConsole","use","static","sendFile","__dirname","startServer","inputSSR","func","json","object","callback","obj"],"mappings":"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"}